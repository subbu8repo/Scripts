Istio is a tool that provides service mesh capabilities
it has network proxy, it takes all your un-encripted requests traffic it will process and encrypt that and send it to the pods it will encrypt(mtls) all the engress traffic

Istio is an open framework for connecting, securing, managing and monitoring microservices
 istio includes
1. service discovery
2. load balancing
3. failure recovery
4. tele-metrics
5. monitoring
 istio can also handle more complex operational requirements
1. A/B testing
2. canary releases
3. rate limiting
4. dark launches
5. access control
6. end-to-end authentication

what makes istio so unique is that all these functionalities come with no change of code required
istio is diveded into two parts control plane and data plane
control plane has 3 important components pilot, citadel, galley  together all are istiod
pilot handles all the configuration and programming of nyproxy side car and some of the responsibilities is  abserving the service topology, traffic shifting, 
fault injecction, requesting routing, mirroring
citadel provides you keys and certificates to enable secure communication and secure connection between services it also provides strong service to 
service and end user authentication using mtls(mutual transport layer security)
Galley core responsibility is to distribute configuration input to other istio components, it writes istio configuration and pushed sent towoards other istio
components 
pilot manages the configurations
citadel manages the certificates and keys
galley stores the istio configuration and pushed to other istio components
network proxy reponsible for intercepting the communication and appling the polices you have set
the main responsibility of control plane is it enables secure access and communication between services in a policy driven way
data plane is implemented in such a way that it intercepts all inbound and outbound traffic from services like loadbalancer or nodeport whichever the service 
you are using it will intercept all the traffic
service mesh is nothing but the network routing which is happening for your micro service applications, service mesh provides you network proxy and it is  
intercepting all the traffic coming inside going outside based on policies you have set the network is allowed and the network is denied.

setting-up istio and injecting sidecar container

base should be K8s
istio installation from official website and istio getting started, Download Istio

curl -L https://istio.io/downloadIstio | sh -
ls
cd istio-1.21.2
export PATH=$PWD/bin:$PATH
istioctl install --set profile=demo -y                # (demo, default, minimal, remote, empty, preview in real we use default one wherein you will be encrypting)
                                                      # kubectl label namespace default istio-injection=enabled
                                                      # by default side car container will not be injected, multiple ways to inject oneway is check labels, 
                                                      # at the namespace labels level we can inject sidecar container
                                                      # and any services or any resources which is getting created inside this namespace will have the side car 
                                                      # container automatically post that

cd ~                                                  #   all the ingress network traffic )
kubectl get all
kubectl get ns                                         # you can see istio
kubectl get all -n istio-system
cd istio-1.21.2                                        # go to path
kubectl apply -f samples/addons/                       # this will install many addons like kiali, prometheous, grafana.......
cd samples/addons/
ls -l
cd ~
sudo docker pull devopsmela/java-numeric-app
sudo docker pull devopsmela/node-js:v1
sudo docker images

#nsetting up java application into K8s pods

kubectl create ns dev
kubectl get ns 

vim deployment.yaml

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-java
spec:                  
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template: 
    metadata:
      labels:
        app: my-app
    spec: 
      containers:
      - name: my-image
        image: devopsmela/java-numeric-app
        ports:
        - containerPort: 8080                      # check the requirement that java application listens on which port

vi service.yaml

apiVersion: v1
kind: Service
metadata: 
  name: my-service-java
spec:
  type: NodePort
  selector:
    app: my-app
  ports:
  - port: 8080

kubectl apply -f deployment.yaml -n dev 
kubectl apply -f service.yaml -n dev             # 2-tier application frontend written in java springboot and backend in node-js
kubectl get all -n dev                         # this java has 3 modules home directory(/), compare, incremental you can check by curl using nodeport of service
curl 10.108.157.70:8080                     # it shows welcome to devops
curl 10.108.157.70:8080/compare/50           # Smaller than or equal to 50 till her happened in java application 
curl 10.108.157.70:8080/increment/99         # it gives 100 but to work this we need node-js images and deployment also as this increment happens in backend
                                             # application node-js
kubectl describe -n dev podname

# you can see only one container 1/1 ready by default side car container will not be injected, multiple ways to inject oneway is check labels, at the 
# namespace labels level we can inject sidecar container then you can see 2/2 ready


kiali basically gives you a animated view of how the network is floeing through your services, kiali comes with istio when setting up istio and kiali will give 
you complete network topology view, by seeing kiali dashboard you can identify whether the traffic is encrypted or not whether the application health is healthy
or not whether the pod is running or not all this can be done using kiali monitoring tool

kubectl get all -n istio-system                 # to access from outside world change clusterio to nodeport in service kiali
kubectl edit service/kiali -n istio-system
kubectl get all -n istio-system

# allow the inbound traffic open port with nodeport using vm public ip and nodeport
# open kiali dashboard see namespace and send some traffic by using while loop and do curl and watch

kubectl get all -n dev
while true; do curl 10.108.157.70:8080/compare/51; echo; sleep 1; done 

# we dont have a side car container thats why it is not showing anything
# by default side car container will not be injected, multiple ways to inject oneway is check labels, at the namespace labels level we can inject sidecar container
# and any services or any resources which is getting created inside this namespace will have the side car container automatically post that
# already some services running in prod and that will not replicated to istio because it already created but it can be integrated

kubectl get ns --show-labels













